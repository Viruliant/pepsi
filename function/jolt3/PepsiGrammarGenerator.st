"THIS FILE WAS GENERATED AUTOMATICALLY -- DO NOT EDIT!"

{ import: GrammarParser }
PepsiGrammarGenerator : GrammarParser (name depth maxDepth)
PepsiGrammarGenerator start :inputStream [
| pos1 |
^(((pos1 := inputStream position)
 and: [(self header :inputStream)
 and: [((inputStream pushGroup: (TokenGroup new add: ((self Grammar :inputStream)))) ifTrue: [(self generate :inputStream)])]])
 or: [(inputStream position: pos1)])
]
PepsiGrammarGenerator header :inputStream [
^([ '"THIS FILE WAS GENERATED AUTOMATICALLY -- DO NOT EDIT!"\n\n' put ] value)
]
PepsiGrammarGenerator generate :inputStream [
| i p v l id e a x s c pos1 pos2 pos3 pos4 pos5 pos6 pos7 pos8 |
^((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #grammar) ifTrue: [result := inputStream next. 1])
 and: [((pos3 := TokenGroup new)
 and: [[(self generate :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #declaration) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])
 and: [([ 123 put. (' import: ', p, ' ') put.  125 putln.
								  ((name := i asString), ' : ', p, ' (') put ] value)
 and: [(((pos4 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((pos5 := TokenGroup new)
 and: [[(((pos6 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])
 and: [([v asString put] value)
 and: [(((pos7 := inputStream position)
 and: [(((pos8 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([' ' put] value)]])
 or: [(inputStream position: pos8)])]) ifTrue: [(inputStream position: pos7). 1])]]])
 or: [(inputStream position: pos6)])] whileTrue: [(pos5 add: result)]. (result := pos5)])]]) ifTrue: [(result := (inputStream := pos4) next)] ifFalse: [(inputStream := pos4). nil])]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')') putln ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #definition) ifTrue: [result := inputStream next. 1])
 and: [([ maxDepth := depth := 0 ] value)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [l := result. 1])
 and: [(((pos4 := inputStream position)
 and: [(self reserve :inputStream)]) ifTrue: [(inputStream position: pos4). 1])
 and: [([ (name, ' ', i, ' :inputStream [') putln.
								  maxDepth > 0 ifTrue: [1 to: maxDepth do: [:n | l add: 'pos', n printString]].
								  l notEmpty ifTrue: ['|' put.  l do: [:n | (' ', n) put].  ' |' putln].
								  p do: [:n | n asString put.  ' := inputStream next.' putln].
								  '^' put ] value)
 and: [(self generate :inputStream)]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('\n]') putln ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #alternatives) ifTrue: [result := inputStream next. 1])
 and: [([ '(' put ] value)
 and: [(((pos3 := inputStream position)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(self generate :inputStream)
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6). 1])
 and: [(['\n or: [' put] value)]]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]) ifTrue: [(inputStream position: pos3). 1])
 and: [((pos3 := TokenGroup new)
 and: [[(((pos4 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [(((pos5 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos5). 1])
 and: [([       ']' put] value)]]])
 or: [(inputStream position: pos4)])] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ ')' put ] value)]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put ] value)
 and: [(self save :inputStream)
 and: [(((pos3 := inputStream position)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(['\n and: [' put] value)
 and: [(self generate :inputStream)]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]) ifTrue: [(inputStream position: pos3). 1])
 and: [((pos3 := TokenGroup new)
 and: [[(((pos4 := inputStream position)
 and: [([        ']' put] value)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]])
 or: [(inputStream position: pos4)])] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ ')\n or: [' put ] value)
 and: [(self restore :inputStream)
 and: [([ '])' put ] value)]]]]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #and) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put ] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put ] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [' put ] value)
 and: [(self restore :inputStream)]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. 1])' put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #not) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put ] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put ] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [' put ] value)
 and: [(self restore :inputStream)]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '] ifFalse: [1])' put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #store) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [id := result. 1])
 and: [([ ('(') put ] value)
 and: [(self generate :inputStream)]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('\n and: [', id, ' := result. 1])') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #text) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put ] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put ] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [result := (' put ] value)
 and: [(self position :inputStream)
 and: [([ ' text: inputStream position)])' put ] value)
 and: [(self release :inputStream)]]]]]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #zeroOne) ifTrue: [result := inputStream next. 1])
 and: [([ ('((') put ] value)
 and: [(self generate :inputStream)]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (') ifTrue: [result := TokenGroup with: result] ifFalse: [result := TokenGroup new])') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #zeroMany) ifTrue: [result := inputStream next. 1])
 and: [([ '(' put ] value)
 and: [(self bgroup :inputStream)
 and: [([ '\n and: [[' put ] value)
 and: [(self generate :inputStream)
 and: [([ '] whileTrue: [' put ] value)
 and: [(self append :inputStream)
 and: [([ ']. ' put ] value)
 and: [(self egroup :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '])' put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #oneMany) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [e := result. 1])
 and: [([ '(' put ] value)
 and: [(self bgroup :inputStream)
 and: [([ '\n and: [((' put ] value)
 and: [((inputStream pushGroup: (TokenGroup new add: (e))) ifTrue: [(self generate :inputStream)])
 and: [([ ') ifTrue: [' put ] value)
 and: [(self append :inputStream)
 and: [([ '. 1])\n and: [[' put ] value)
 and: [((inputStream pushGroup: (TokenGroup new add: (e))) ifTrue: [(self generate :inputStream)])
 and: [([ '] whileTrue: [' put ] value)
 and: [(self append :inputStream)
 and: [([ ']. ' put ] value)
 and: [(self egroup :inputStream)]]]]]]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. 1]])' put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((inputStream peek == #dot) ifTrue: [result := inputStream next. 1])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(inputStream notAtEnd and: [result := inputStream next. 1])') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #answer) ifTrue: [result := inputStream next. 1])
 and: [((((pos3 := inputStream position)
 and: [(((pos4 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos5 := inputStream position)
 and: [((inputStream peek == #action) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [a := result. 1])]])
 or: [(inputStream position: pos5)])]]) ifTrue: [(result := (inputStream := pos4) next)] ifFalse: [(inputStream := pos4). nil])
 and: [([ ('((result := ([', a, '] value))\n or: [1])') put ] value)]])
 or: [(inputStream position: pos3)])
 or: [(((pos3 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [a := result. 1])
 and: [([ a isSymbol ] value)
 and: [([ ('((result := ', a, ')\n or: [1])') put ] value)]]])
 or: [(inputStream position: pos3)])])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #action) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [a := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('([', a, '] value)') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #invoke) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [(((pos4 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos4)] ifFalse: [1])]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self ', i, ' :inputStream)') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #invoke) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [([ ('((inputStream pushGroup: (TokenGroup new') put ] value)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6). 1])
 and: [([ ' add: (' put ] value)
 and: [(self generate :inputStream)
 and: [([ ')' put ] value)
 and: [(((pos6 := inputStream position)
 and: [(((((pos7 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([';' put] value)]])
 or: [(inputStream position: pos7)])) ifTrue: [result := TokenGroup with: result] ifFalse: [result := TokenGroup new])]) ifTrue: [(inputStream position: pos6). 1])]]]]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')) ifTrue: [(self ', i, ' :inputStream)])') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #argvar) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x asString put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #arglit) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x printString put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #literal) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [l := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((inputStream peek == ', l printString, ') ifTrue: [result := inputStream next. 1])') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #string) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self string: ', s printString, ' :inputStream)') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #class) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [c := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self class: ', c printString, ' :inputStream)') put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #structure) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put ] value)
 and: [(self bstream :inputStream)
 and: [([ '\n and: [(inputStream := self beginStructure: inputStream)\n and: [' put ] value)
 and: [(self generate :inputStream)
 and: [([ ']]) ifTrue: [' put ] value)
 and: [(self nstream :inputStream)
 and: [([ '] ifFalse: [' put ] value)
 and: [(self estream :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. nil])' put ] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])
 and: [([ self error: 'unknown expression: ', x printString ] value)]])
 or: [(inputStream position: pos1)])]]]]]]]]]]]]]]]]]]]]]]])
]
PepsiGrammarGenerator reserve :inputStream [
| pos1 pos2 pos3 |
^((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [(((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #and) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #not) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #text) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #zeroMany) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #oneMany) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #structure) ifTrue: [result := inputStream next. 1])]]]]]])
 and: [([ maxDepth := maxDepth max: (depth := depth + 1) ] value)
 and: [((pos3 := TokenGroup new)
 and: [[(self reserve :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ depth := depth - 1 ] value)]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [((pos3 := TokenGroup new)
 and: [[(self reserve :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(inputStream notAtEnd and: [result := inputStream next. 1])]])
]
PepsiGrammarGenerator save :inputStream [
^([ ('(pos', (depth := depth + 1) printString, ' := inputStream position)') put ] value)
]
PepsiGrammarGenerator position :inputStream [
^([ ('pos', depth printString) put ] value)
]
PepsiGrammarGenerator restore :inputStream [
^([ ('(inputStream position: pos', depth printString, ')') put.  depth := depth - 1 ] value)
]
PepsiGrammarGenerator release :inputStream [
^([ depth := depth - 1 ] value)
]
PepsiGrammarGenerator bgroup :inputStream [
^([ ('(pos', (depth := depth + 1) printString, ' := TokenGroup new)') put ] value)
]
PepsiGrammarGenerator append :inputStream [
^([ ('(pos', depth printString, ' add: result)') put ] value)
]
PepsiGrammarGenerator egroup :inputStream [
^([ ('(result := pos', depth printString, ')') put.  depth := depth - 1 ] value)
]
PepsiGrammarGenerator bstream :inputStream [
^([ ('(pos', (depth := depth + 1) printString, ' := inputStream)') put ] value)
]
PepsiGrammarGenerator nstream :inputStream [
^([ ('(result := (inputStream := pos', depth printString, ') next)') put ] value)
]
PepsiGrammarGenerator estream :inputStream [
^([ ('(inputStream := pos', depth printString, ')') put.  depth := depth - 1 ] value)
]
