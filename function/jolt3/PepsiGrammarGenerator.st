"THIS FILE WAS GENERATED AUTOMATICALLY -- DO NOT EDIT!"

{ import: GrammarParser }
PepsiGrammarGenerator : GrammarParser (name depth maxDepth)
PepsiGrammarGenerator start :inputStream
[
| pos1 |
^(((pos1 := inputStream position)
 and: [(self Header :inputStream)
 and: [((inputStream pushGroup: (TokenGroup new add: (((self Grammar :inputStream)) ifTrue: [result] ifFalse: [result]))) ifTrue: [(self Generate :inputStream)])]])
 or: [(inputStream position: pos1)])
]
PepsiGrammarGenerator Header :inputStream
[
^([ '"THIS FILE WAS GENERATED AUTOMATICALLY -- DO NOT EDIT!"\n\n' put . 1] value)
]
PepsiGrammarGenerator Generate :inputStream
[
| i p v l pos1 pos2 pos3 pos4 pos5 pos6 pos7 pos8 |
^((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #grammar) ifTrue: [result := inputStream next. 1])
 and: [((pos3 := TokenGroup new)
 and: [[(self Generate :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #declaration) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])
 and: [([ ('{ import: ', p, ' }') putln.  ((name := i asString), ' : ', p, ' (') put . 1] value)
 and: [(((pos4 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((pos5 := TokenGroup new)
 and: [[(((pos6 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])
 and: [([v asString put. 1] value)
 and: [(((pos7 := inputStream position)
 and: [(((pos8 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([' ' put. 1] value)]])
 or: [(inputStream position: pos8)])]) ifTrue: [(inputStream position: pos7). 1])]]])
 or: [(inputStream position: pos6)])] whileTrue: [(pos5 add: result)]. (result := pos5)])]]) ifTrue: [(result := (inputStream := pos4) next)] ifFalse: [(inputStream := pos4). nil])]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')') putln . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #definition) ifTrue: [result := inputStream next. 1])
 and: [([ maxDepth := depth := 0 . 1] value)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [l := result. 1])
 and: [(((pos4 := inputStream position)
 and: [(self reserve :inputStream)]) ifTrue: [(inputStream position: pos4). 1])
 and: [([ (name, ' ', i, ' :inputStream\n[') putln.
								  maxDepth > 0 ifTrue: [1 to: maxDepth do: [:n | l add: 'pos', n printString]].
								  l notEmpty ifTrue: ['|' put.  l do: [:n | (' ', n) put].  ' |' putln].
								  p do: [:n | n asString put.  ' := inputStream next.' putln]. . 1] value)
 and: [(self Generate :inputStream)]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ']' putln . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [([ '^' put. . 1] value)
 and: [(self generate :inputStream)
 and: [([ '\n' put. . 1] value)]]])
 or: [(inputStream position: pos1)])]]])
]
PepsiGrammarGenerator generate :inputStream
[
| id e v a p i x l s c pos1 pos2 pos3 pos4 pos5 pos6 pos7 |
^((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #alternatives) ifTrue: [result := inputStream next. 1])
 and: [([ '(' put . 1] value)
 and: [(((pos3 := inputStream position)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(self generate :inputStream)
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6). 1])
 and: [(['\n or: [' put. 1] value)]]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]) ifTrue: [(inputStream position: pos3). 1])
 and: [((pos3 := TokenGroup new)
 and: [[(((pos4 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [(((pos5 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos5). 1])
 and: [([       ']' put. 1] value)]]])
 or: [(inputStream position: pos4)])] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ ')' put . 1] value)]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [(((pos3 := inputStream position)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(['\n and: [' put. 1] value)
 and: [(self generate :inputStream)]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]) ifTrue: [(inputStream position: pos3). 1])
 and: [((pos3 := TokenGroup new)
 and: [[(((pos4 := inputStream position)
 and: [([        ']' put. 1] value)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]])
 or: [(inputStream position: pos4)])] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ ')\n or: [' put . 1] value)
 and: [(self restore :inputStream)
 and: [([ '])' put . 1] value)]]]]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #and) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [' put . 1] value)
 and: [(self restore :inputStream)]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. 1])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #not) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [' put . 1] value)
 and: [(self restore :inputStream)]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '] ifFalse: [1])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #store) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [id := result. 1])
 and: [([ ('(') put . 1] value)
 and: [(self generate :inputStream)]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('\n and: [', id, ' := result. 1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #text) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [result := (' put . 1] value)
 and: [(self position :inputStream)
 and: [([ ' text: inputStream position)])' put . 1] value)
 and: [(self release :inputStream)]]]]]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #zeroOne) ifTrue: [result := inputStream next. 1])
 and: [([ ('((') put . 1] value)
 and: [(self generate :inputStream)]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (') ifTrue: [result := TokenGroup with: result] ifFalse: [result := TokenGroup new])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #zeroMany) ifTrue: [result := inputStream next. 1])
 and: [([ '(' put . 1] value)
 and: [(self bgroup :inputStream)
 and: [([ '\n and: [[' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ '] whileTrue: [' put . 1] value)
 and: [(self append :inputStream)
 and: [([ ']. ' put . 1] value)
 and: [(self egroup :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #oneMany) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [e := result. 1])
 and: [([ '(' put . 1] value)
 and: [(self bgroup :inputStream)
 and: [([ '\n and: [((' put . 1] value)
 and: [((inputStream pushGroup: (TokenGroup new add: e)) ifTrue: [(self generate :inputStream)])
 and: [([ ') ifTrue: [' put . 1] value)
 and: [(self append :inputStream)
 and: [([ '. 1])\n and: [[' put . 1] value)
 and: [((inputStream pushGroup: (TokenGroup new add: e)) ifTrue: [(self generate :inputStream)])
 and: [([ '] whileTrue: [' put . 1] value)
 and: [(self append :inputStream)
 and: [([ ']. ' put . 1] value)
 and: [(self egroup :inputStream)]]]]]]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. 1]])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((inputStream peek == #dot) ifTrue: [result := inputStream next. 1])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(inputStream notAtEnd and: [result := inputStream next. 1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #value) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((result := [', v, '] value) or: [1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #variable) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((result := ' , v,        ') or: [1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #action) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [a := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('([', a, '. 1] value)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #predicate) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('([', p, '] value)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #invoke) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [(((pos4 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos4)] ifFalse: [1])]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self ', i, ' :inputStream)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #invoke) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [([ ('((inputStream pushGroup: (TokenGroup new') put . 1] value)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6). 1])
 and: [([ ' add: ' put . 1] value)
 and: [(self generate :inputStream)
 and: [(((pos6 := inputStream position)
 and: [(((((pos7 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([';' put. 1] value)]])
 or: [(inputStream position: pos7)])) ifTrue: [result := TokenGroup with: result] ifFalse: [result := TokenGroup new])]) ifTrue: [(inputStream position: pos6). 1])]]]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')) ifTrue: [(self ', i, ' :inputStream)])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #argvar) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x asString put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #arglit) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x printString put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #result) ifTrue: [result := inputStream next. 1])
 and: [(['((' put. 1] value)
 and: [(self generate :inputStream)]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ') ifTrue: [result] ifFalse: [result])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #literal) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [l := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((inputStream peek == ', l printString, ') ifTrue: [result := inputStream next. 1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #string) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self string: ', s printString, ' :inputStream)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #class) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [c := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self class: ', c printString, ' :inputStream)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #structure) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self bstream :inputStream)
 and: [([ '\n and: [(inputStream := self beginStructure: inputStream)\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']]) ifTrue: [' put . 1] value)
 and: [(self nstream :inputStream)
 and: [([ '] ifFalse: [' put . 1] value)
 and: [(self estream :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. nil])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])
 and: [([ self error: 'unknown expression: ', x printString . 1] value)]])
 or: [(inputStream position: pos1)])]]]]]]]]]]]]]]]]]]]]]]])
]
PepsiGrammarGenerator reserve :inputStream
[
| pos1 pos2 pos3 |
^((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [(((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #and) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #not) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #text) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #zeroMany) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #oneMany) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #structure) ifTrue: [result := inputStream next. 1])]]]]]])
 and: [([ maxDepth := maxDepth max: (depth := depth + 1) . 1] value)
 and: [((pos3 := TokenGroup new)
 and: [[(self reserve :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ depth := depth - 1 . 1] value)]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [((pos3 := TokenGroup new)
 and: [[(self reserve :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(inputStream notAtEnd and: [result := inputStream next. 1])]])
]
PepsiGrammarGenerator save :inputStream
[
^([ ('(pos', (depth := depth + 1) printString, ' := inputStream position)') put . 1] value)
]
PepsiGrammarGenerator position :inputStream
[
^([ ('pos', depth printString) put . 1] value)
]
PepsiGrammarGenerator backup :inputStream
[
^([ ('(inputStream position: pos', depth printString, ')') put . 1] value)
]
PepsiGrammarGenerator restore :inputStream
[
^([ ('(inputStream position: pos', depth printString, ')') put.  depth := depth - 1 . 1] value)
]
PepsiGrammarGenerator release :inputStream
[
^([ depth := depth - 1 . 1] value)
]
PepsiGrammarGenerator bgroup :inputStream
[
^([ ('(pos', (depth := depth + 1) printString, ' := TokenGroup new)') put . 1] value)
]
PepsiGrammarGenerator append :inputStream
[
^([ ('(pos', depth printString, ' add: result)') put . 1] value)
]
PepsiGrammarGenerator egroup :inputStream
[
^([ ('(result := pos', depth printString, ')') put.  depth := depth - 1 . 1] value)
]
PepsiGrammarGenerator bstream :inputStream
[
^([ ('(pos', (depth := depth + 1) printString, ' := inputStream)') put . 1] value)
]
PepsiGrammarGenerator nstream :inputStream
[
^([ ('(result := (inputStream := pos', depth printString, ') next)') put . 1] value)
]
PepsiGrammarGenerator estream :inputStream
[
^([ ('(inputStream := pos', depth printString, ')') put.  depth := depth - 1 . 1] value)
]
